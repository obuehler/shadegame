//
//  CUObstacleSelector.h
//  Cornell Extensions to Cocos2D
//
//  This class implements a selection tool for dragging physics objects with a mouse.
//  It is essentially an instance of b2MouseJoint, but with an API that makes it a lot
//  easier to use. As with all instances of b2MouseJoint, there will be some lag in
//  the drag (though this is true on touch devices in general).  You can adjust the
//  degree of this lag by adjusting the force.  However, larger forces can cause artifacts
//  when dragging an obstacle through other obstacles.
//
//  This file is based on the CS 3152 PhysicsDemo Lab by Don Holden, 2007
//
//  Author: Walker White
//  Version: 12/28/15
//

#include "CUObstacle.h"
#include "CUObstacleSelector.h"
#include <Box2D/Dynamics/b2World.h>
#include <Box2D/Collision/Shapes/b2CircleShape.h>

NS_CC_BEGIN

#pragma mark -
#pragma mark Static Constructors

/**
 * Creates a new ObstacleSelector for the given WorldController
 *
 * This controller can never change.  If you want a selector for a different
 * WorldController, make a new instance.
 *
 * This constructor uses the default mouse size.
 *
 * @param  controller   the physics controller
 *
 * @retain a reference to the world controller
 * @return an autoreleased selector object
 */
ObstacleSelector* ObstacleSelector::create(WorldController* controller) {
    ObstacleSelector* selector = new (std::nothrow) ObstacleSelector();
    if (selector && selector->init(controller)) {
        selector->autorelease();
        return selector;
    }
    CC_SAFE_DELETE(selector);
    return nullptr;
}

/**
 * Creates a new ObstacleSelector for the given WorldController and mouse size.
 *
 * This controller can never change.  If you want a selector for a different
 * WorldController, make a new instance.  However, the mouse size can be changed
 * at any time.
 *
 * @param  controller   the physics controller
 *
 * @retain a reference to the world controller
 * @return an autoreleased selector object
 */
ObstacleSelector* ObstacleSelector::create(WorldController* controller, const Size& mouseSize) {
    ObstacleSelector* selector = new (std::nothrow) ObstacleSelector();
    if (selector && selector->init(controller, mouseSize)) {
        selector->autorelease();
        return selector;
    }
    CC_SAFE_DELETE(selector);
    return nullptr;
}

#pragma mark -
#pragma mark Initializers

/**
 * Initializes a new ObstacleSelector for the given WorldController and mouse size.
 *
 * This controller can never change.  If you want a selector for a different
 * WorldController, make a new instance.  However, the mouse size can be changed
 * at any time.
 *
 * @param  controller   the physics controller
 *
 * @retain a reference to the world controller
 * @return  true if the obstacle is initialized properly, false otherwise.
 */
bool ObstacleSelector::init(WorldController* controller, const Size& mouseSize) {
    _controller = controller;
    _controller->retain();
    
    _pointer.size = mouseSize;
    
    _jointDef.frequencyHz = DEFAULT_FREQUENCY;
    _jointDef.dampingRatio = DEFAULT_DAMPING;
    _force = DEFAULT_FORCE;
    
    b2BodyDef groundDef;
    groundDef.type = b2_staticBody;
    b2CircleShape groundShape;
    groundShape.m_radius = _pointer.size.width;
    
    _ground = _controller->getWorld()->CreateBody(&groundDef);
    if (_ground != nullptr) {
        b2FixtureDef groundFixture;
        groundFixture.shape = &groundShape;
        return _ground->CreateFixture(&groundFixture) != nullptr;
    }
    
    return false;
}

/**
 * Disposes of this selector, releasing all resources.
 */
ObstacleSelector::~ObstacleSelector(void) {
    if (_mouseJoint != nullptr) {
        _controller->getWorld()->DestroyJoint(_mouseJoint);
    }
    
    _controller->getWorld()->DestroyBody(_ground);
    _controller->release();
}


#pragma mark -
#pragma mark Selection Methods

/**
 * Returns the Obstacle selected (if any)
 *
 * Just because a physics body was selected does not mean that an Obstacle was
 * selected.  The body could be a basic Box2d body generated by other means.
 * If the body is not an Obstacle, this method returns nullptr.
 *
 * @return the Obstacle selected (if any)
 */
Obstacle* ObstacleSelector::getObstacle() {
    if (_selection != nullptr) {
        void* data = _selection->GetBody()->GetUserData();
        if (data != nullptr) {
            // TODO: Cannot dynamic cast void pointer.  Is there alternative?
            return (Obstacle*)data;
        }
    }
    return nullptr;
}

/**
 * Returns true if a physics body was selected at the given position.
 *
 * This method contructs and AABB the size of the mouse pointer, centered at the
 * given position.  If any part of the AABB overlaps a fixture, it is selected.
 *
 * @param  pos  the position (in physics space) to select
 *
 * @return true if a physics body was selected at the given position.
 */
bool ObstacleSelector::select(const Vec2& pos) {
    std::function<bool(b2Fixture* fixture)> callback = [this](b2Fixture* fixture) {
        return onQuery(fixture);
    };
    
    _pointer.origin.set(pos.x-_pointer.size.width/2.0f, pos.y-_pointer.size.height/2.0f);
    
    _controller->queryAABB(callback,_pointer);
    if (_selection != nullptr) {
        b2Body* body = _selection->GetBody();
        _jointDef.bodyA = _ground;
        _jointDef.bodyB = body;
        _jointDef.maxForce = _force * body->GetMass();
        _jointDef.target.Set(pos.x,pos.y);
        _mouseJoint = (b2MouseJoint*)_controller->getWorld()->CreateJoint(&_jointDef);
        body->SetAwake(true);
    }
    
    return _selection != nullptr;
}

/**
 * Moves the selected body to the given position.
 *
 * @param  pos  the position (in physics space) to move to
 *
 * If nothing is selected, this method does nothing.
 */
void ObstacleSelector::moveTo(const Vec2& pos) {
    _mouseJoint->SetTarget(b2Vec2(pos.x,pos.y));
}

/**
 * Deselects the physics body, discontinuing any mouse movement.
 *
 * The body may still continue to move of its own accord.
 */
void ObstacleSelector::deselect() {
    if (_selection != nullptr) {
        _controller->getWorld()->DestroyJoint(_mouseJoint);
        _selection = nullptr;
        _mouseJoint = nullptr;
    }
}

/**
 * Callback function for mouse selection.
 *
 * This is the callback function used by the method queryAABB to select a physics
 * body at the current mouse location.
 *
 * @param  fixture  the fixture selected
 *
 * @return false to terminate the query.
 */
bool ObstacleSelector::onQuery(b2Fixture* fixture) {
    _selection = fixture;
    return _selection == nullptr;
}

NS_CC_END
